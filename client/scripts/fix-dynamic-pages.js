// scripts/fix-dynamic-pages.js
// Usage:
//   node scripts/fix-dynamic-pages.js --dry-run
//   node scripts/fix-dynamic-pages.js
//
// 목적:
// - src/pages/** 안의 동적 세그먼트 폴더([id], [slug] 등)를 제거하고
//   내부 콘텐츠를 부모의 ui/ 로 승격
// - 각 페이지 폴더에 index.ts 자동 생성/갱신
//
// 안전장치:
// - --dry-run 플래그로 시뮬레이션
// - 이동 대상 파일이 이미 존재하면 *.moved 로 이름 변경하여 보존

const fs = require('fs');
const fsp = fs.promises;
const path = require('path');

const DRY_RUN = process.argv.includes('--dry-run');
const ROOT = process.cwd();
const SRC_PAGES = path.join(ROOT, 'src', 'pages');

function log(...args) { console.log('[fix-dynamic]', ...args); }
function warn(...args) { console.warn('[fix-dynamic][warn]', ...args); }

async function exists(p) {
  try { await fsp.access(p, fs.constants.F_OK); return true; }
  catch { return false; }
}
async function ensureDir(dir) {
  if (DRY_RUN) return;
  await fsp.mkdir(dir, { recursive: true });
}
async function rmDir(dir) {
  if (DRY_RUN) return;
  await fsp.rm(dir, { recursive: true, force: true });
}
async function writeFile(p, content) {
  if (DRY_RUN) {
    log('write:', path.relative(ROOT, p));
    return;
  }
  await ensureDir(path.dirname(p));
  await fsp.writeFile(p, content, 'utf8');
}

async function safeMoveFile(src, dest) {
  await ensureDir(path.dirname(dest));
  if (await exists(dest)) {
    const parsed = path.parse(dest);
    const alt = path.join(parsed.dir, parsed.name + '.moved' + parsed.ext);
    log('conflict -> rename:', path.relative(ROOT, dest), '=>', path.relative(ROOT, alt));
    dest = alt;
  }
  if (DRY_RUN) {
    log('move:', path.relative(ROOT, src), '->', path.relative(ROOT, dest));
    return;
  }
  try {
    await fsp.rename(src, dest);
  } catch {
    await fsp.copyFile(src, dest);
    await fsp.unlink(src);
  }
}

async function moveDirContent(srcDir, destDir) {
  const entries = await fsp.readdir(srcDir, { withFileTypes: true });
  for (const e of entries) {
    const s = path.join(srcDir, e.name);
    const d = path.join(destDir, e.name);
    if (e.isDirectory()) {
      await moveDirContent(s, d);
    } else {
      await safeMoveFile(s, d);
    }
  }
}

function pascalCaseFromFilename(file) {
  const base = file.replace(/\.[^.]+$/, '');
  const name = base.split(/[^a-zA-Z0-9]+/).filter(Boolean)
    .map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('');
  return name;
}

async function chooseMainUiFile(uiDir) {
  if (!(await exists(uiDir))) return null;
  const files = (await fsp.readdir(uiDir))
    .filter(f => /\.(tsx|ts|jsx|js)$/.test(f));
  if (files.length === 0) return null;

  const byPriority = [
    f => /page\.(tsx|ts|jsx|js)$/.test(f),   // *-page.tsx 우선
    f => /^index\.(tsx|ts|jsx|js)$/.test(f), // index.tsx 다음
  ];
  for (const pred of byPriority) {
    const pick = files.find(pred);
    if (pick) return pick;
  }
  return files[0];
}

async function ensureIndexExport(folder) {
  const uiDir = path.join(folder, 'ui');
  const main = await chooseMainUiFile(uiDir);
  if (!main) {
    warn('ui 파일을 못찾음 (index.ts 생략):', path.relative(ROOT, folder));
    return;
  }

  const base = main.replace(/\.[^.]+$/, '');
  let exportName = pascalCaseFromFilename(base);
  // 파일명이 Page를 포함하지 않으면 접미사 Page 추가
  if (!/Page$/.test(exportName)) exportName += 'Page';

  const indexTs = path.join(folder, 'index.ts');
  const content =
    `// auto-generated by fix-dynamic-pages
export { default as ${exportName} } from './ui/${base}';
`;
  await writeFile(indexTs, content);
}

function isDynamicSegmentName(name) {
  return /^\[.+\]$/.test(name);
}

async function walk(dir, cb) {
  const entries = await fsp.readdir(dir, { withFileTypes: true });
  for (const e of entries) {
    const p = path.join(dir, e.name);
    await cb(p, e);
    if (e.isDirectory()) {
      await walk(p, cb);
    }
  }
}

async function collapseDynamicSegments() {
  const dynamicDirs = [];

  await walk(SRC_PAGES, async (abs, ent) => {
    if (ent.isDirectory() && isDynamicSegmentName(ent.name)) {
      dynamicDirs.push(abs);
    }
  });

  // 정렬: 경로 길이 긴 것부터(하위 먼저 처리)
  dynamicDirs.sort((a, b) => b.length - a.length);

  for (const dynDir of dynamicDirs) {
    const parent = path.dirname(dynDir);
    const uiInside = path.join(dynDir, 'ui');
    const parentUi = path.join(parent, 'ui');

    if (await exists(uiInside)) {
      log('hoist ui/:', path.relative(ROOT, dynDir), '->', path.relative(ROOT, parentUi));
      await ensureDir(parentUi);
      await moveDirContent(uiInside, parentUi);
    } else {
      log('hoist all -> parent/ui:', path.relative(ROOT, dynDir), '->', path.relative(ROOT, parentUi));
      await ensureDir(parentUi);
      await moveDirContent(dynDir, parentUi);
    }

    // 동적 폴더 정리
    log('remove:', path.relative(ROOT, dynDir));
    await rmDir(dynDir);

    // 부모 폴더에 index.ts 보장
    await ensureIndexExport(parent);
  }
}

async function ensureIndexesForAllPageFolders() {
  // src/pages/**/ui가 있는 모든 폴더에 index.ts 보장
  const candidates = new Set();
  await walk(SRC_PAGES, async (abs, ent) => {
    if (ent.isDirectory() && path.basename(abs) === 'ui') {
      candidates.add(path.dirname(abs));
    }
  });
  for (const folder of candidates) {
    await ensureIndexExport(folder);
  }
}

async function main() {
  if (!(await exists(SRC_PAGES))) {
    warn('src/pages 폴더가 없습니다. 종료.');
    return;
  }
  log('START', DRY_RUN ? '(dry-run)' : '');
  await collapseDynamicSegments();
  await ensureIndexesForAllPageFolders();
  log('DONE ✅', DRY_RUN ? '(dry-run only)' : '');
  log('주의: app/** 의 page.tsx 래퍼에서 params를 props로 넘겨주는 코드는 직접 유지하세요.');
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
